import pygame
import pygame.freetype
from PIL import Image
import tkinter as tk
from tkinter import filedialog, messagebox
import random
import math
import os
import sys


def resource_path(relative_path):
    """ Get absolute path to resource, works for dev and for PyInstaller """
    try:
        # PyInstaller creates a temp folder and stores path in _MEIPASS
        base_path = sys._MEIPASS
        print(f"Using PyInstaller base path: {base_path}")
    except Exception:
        base_path = os.path.abspath(".")
        print(f"Using default base path: {base_path}")

    full_path = os.path.join(base_path, relative_path)
    print(f"Attempting to load CSV from: {full_path}")
    return full_path

# Inicializar pygame y tkinter
pygame.init()
pygame.mixer.init()  # Inicializar el módulo de sonido
root = tk.Tk()
root.withdraw()  # Ocultar la ventana principal de tkinter

current_dir = os.path.dirname(__file__)
# Cargar el sonido flip
flip_sound = pygame.mixer.Sound(current_dir + '/resources/sounds/flip.wav')


# Dimensiones de la ventana y la postal
SCREEN_WIDTH = 1280
SCREEN_HEIGHT = 720
POSTCARD_WIDTH = 864
POSTCARD_HEIGHT = 648

# Definir colores
WHITE = (255, 255, 255)
BLACK = (0, 0, 0)
LIGHTBLUE = (173, 216, 230)
GRAY = (200, 200, 200)
BLUE = (0, 0, 255)
HOVER_COLOR = (100, 149, 237)

# Definir estrellas fugaces
NUM_STARS = 100
stars = []

# Cargar imagen de fondo para la parte trasera de la postal
reverse_image_path = current_dir +  '/resources/background/Reverse.png'
try:
    background_image = pygame.image.load(reverse_image_path)
    background_image = pygame.transform.scale(background_image, (POSTCARD_WIDTH, POSTCARD_HEIGHT))
except pygame.error as e:
    print(f"Error al cargar la imagen de fondo del reverso: {e}")
    background_image = pygame.Surface((POSTCARD_WIDTH, POSTCARD_HEIGHT))
    background_image.fill(WHITE)

# Cargar fuentes personalizadas
font_path = current_dir +  '/resources/font/CloudyEraser.otf'
font_path2 = current_dir +  '/resources/font/JMH.ttf'
font_path3 = current_dir +  '/resources/font/NewSpace.ttf'
try:
    custom_font = pygame.freetype.Font(font_path, 36)
    custom_font2 = pygame.freetype.Font(font_path2, 21)
    custom_font3 = pygame.freetype.Font(font_path3, 36)
except IOError:
    print(f"Error al cargar la fuente personalizada desde {font_path}. Usando Arial por defecto.")
    custom_font = pygame.freetype.SysFont("Arial", 36)
    custom_font2 = pygame.freetype.SysFont("Arial", 36)
    custom_font3 = pygame.freetype.SysFont("Arial", 36)

# Cargar fuente estándar
default_font = pygame.freetype.SysFont("Arial", 36)

# Variables para mensajes
left_message = "Your preset message on the left side"
right_message = "Custom message on the right side"
user_input = ""
text_box_active = False
placeholder_text = "Escribe aquí..."

# Variables para manejar la repetición de la tecla Backspace
backspace_held = False
backspace_time = 0
BACKSPACE_DELAY = 500  # Milisegundos antes de empezar a eliminar
BACKSPACE_REPEAT = 50   # Milisegundos entre cada eliminación

# Variables del cursor
cursor_visible = True
cursor_timer = 0
CURSOR_BLINK_INTERVAL = 500  # Milisegundos

# Crear la ventana principal
screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
pygame.display.set_caption('Interactive Postcard')

# Definir área del cuadro de texto y botón de descarga
TEXT_BOX_RECT = pygame.Rect(0, 0, POSTCARD_WIDTH - 100, 60)
DOWNLOAD_BUTTON_RECT = pygame.Rect(0, 0, POSTCARD_WIDTH - 100, 40)
POSTCARD_RECT = pygame.Rect(0, 0, POSTCARD_WIDTH, POSTCARD_HEIGHT)

# Función para centrar los elementos de la postal
def center_elements():
    total_height = POSTCARD_HEIGHT + 60 + 40 + 40  # Postal + cuadro de texto + botón de descarga + margen
    y_offset = (SCREEN_HEIGHT - total_height) // 2
    POSTCARD_RECT.x = (SCREEN_WIDTH - POSTCARD_WIDTH) // 2
    POSTCARD_RECT.y = y_offset
    TEXT_BOX_RECT.x = POSTCARD_RECT.x + 50
    TEXT_BOX_RECT.y = POSTCARD_RECT.y + POSTCARD_HEIGHT + 10
    DOWNLOAD_BUTTON_RECT.x = POSTCARD_RECT.x + 50
    DOWNLOAD_BUTTON_RECT.y = TEXT_BOX_RECT.y + TEXT_BOX_RECT.height + 10

# Función para generar estrellas fugaces
def generate_stars():
    for _ in range(NUM_STARS):
        x = random.randint(0, SCREEN_WIDTH)
        y = random.randint(0, SCREEN_HEIGHT)
        speed = random.uniform(1, 4)
        brightness = random.randint(150, 255)
        blink_speed = random.uniform(0.01, 0.05)
        stars.append([x, y, speed, brightness, blink_speed])

# Función para mover las estrellas
def move_stars():
    for star in stars:
        star[0] -= star[2] * 4
        star[1] += star[2] * 0.5
        star[3] = 255 * (0.5 + 0.5 * math.sin(pygame.time.get_ticks() * star[4]))
        if star[0] < 0 or star[1] > SCREEN_HEIGHT:
            star[0] = random.randint(SCREEN_WIDTH, SCREEN_WIDTH + 50)
            star[1] = random.randint(0, SCREEN_HEIGHT // 2)

# Función para dibujar las estrellas
def draw_stars():
    for star in stars:
        color = (int(star[3]), int(star[3]), int(star[3]))
        pygame.draw.circle(screen, color, (int(star[0]), int(star[1])), 2)

# Función para dividir texto en líneas
def wrap_text(text, font, max_width):
    lines = []
    words = text.split(' ')
    current_line = ""
    for word in words:
        if font.render(word, BLACK)[0].get_width() > max_width:
            split_word = word
            while font.render(split_word, BLACK)[0].get_width() > max_width:
                for i in range(1, len(split_word)):
                    if font.render(split_word[:i], BLACK)[0].get_width() > max_width:
                        lines.append(split_word[:i-1] + "-")
                        split_word = split_word[i-1:]
                        break
            current_line = split_word
        else:
            test_line = current_line + " " + word if current_line else word
            if font.render(test_line, BLACK)[0].get_width() <= max_width:
                current_line = test_line
            else:
                lines.append(current_line)
                current_line = word
    if current_line:
        lines.append(current_line)
    return lines

# Función para mostrar la parte frontal de la postal
def display_front(image_path):
    # Get the directory of the current script
    # Draw the postcard background
    pygame.draw.rect(screen, LIGHTBLUE, POSTCARD_RECT)

    # Render the text "Front Side" on the postcard
    default_font.render_to(screen, (POSTCARD_RECT.x + POSTCARD_RECT.width // 2 - 100, POSTCARD_RECT.y + POSTCARD_RECT.height // 2 - 18), "Front Side", BLACK)

    # Load and transform the background image
    background_image = pygame.image.load(current_dir + '/resources/planetAI/' + image_path + '.jpg')
    background_image = pygame.transform.scale(background_image, (POSTCARD_WIDTH, POSTCARD_HEIGHT))
    background_image = pygame.transform.flip(background_image, True, False)
    user = pygame.image.load(current_dir + '/resources/character/cropped_face_with_transparent_bg.png')
    astronaut = pygame.image.load(current_dir + '/resources/character/astronaut.png')
    # Scale the astronaut image to make it larger
    user = pygame.transform.scale(user, (POSTCARD_WIDTH // 8, POSTCARD_WIDTH // 8))
    astronaut = pygame.transform.scale(astronaut, (POSTCARD_WIDTH * 0.75, POSTCARD_WIDTH * 0.75))

    astronaut_height = astronaut.get_height()
    astronaut_cropped = astronaut.subsurface((0, 0, astronaut.get_width(), (astronaut_height // 2) - 95))

    astronaut_x = POSTCARD_RECT.x + POSTCARD_RECT.width - (POSTCARD_WIDTH // 1.75)
    astronaut_y = POSTCARD_RECT.y + POSTCARD_RECT.height - (POSTCARD_HEIGHT * 0.35)
    # Draw the background image on the postcard
    screen.blit(background_image, (POSTCARD_RECT.x, POSTCARD_RECT.y))
    screen.blit(user, (astronaut_x + 280, astronaut_y + 53))
    screen.blit(astronaut_cropped, (astronaut_x, astronaut_y))

# Función para renderizar el mensaje predeterminado en el lado izquierdo de la postal
def draw_default_left_message(surface, font, start_x, start_y, max_width, default_message=None):
    if default_message is None:
        default_message = "Your preset message on the left side"
    lines = wrap_text(default_message, font, max_width)
    for i, line in enumerate(lines):
        font.render_to(surface, (start_x, start_y + i * 40), line, BLACK)

# Función para renderizar el mensaje personalizado en el lado derecho de la postal
def draw_custom_right_message(surface, font, start_x, start_y, max_width):
    lines = wrap_text(user_input, font, max_width)
    for i, line in enumerate(lines):
        font.render_to(surface, (start_x, start_y + i * 40), line, BLACK)

# Función para mostrar la parte trasera de la postal
def display_back(left_message):
    screen.blit(background_image, (POSTCARD_RECT.x, POSTCARD_RECT.y))

    left_area_width = POSTCARD_WIDTH // 2 - 40
    right_area_width = POSTCARD_WIDTH // 2 - 40

    left_start_y = POSTCARD_RECT.y + 50
    right_start_y = POSTCARD_RECT.y + POSTCARD_HEIGHT // 2 + 20

    # Llamar a la función específica para poner el mensaje predeterminado en el lado izquierdo
    draw_default_left_message(screen, custom_font2, POSTCARD_RECT.x + 50, left_start_y, left_area_width, left_message)

    # Renderizar el lado derecho (mensaje personalizado)
    draw_custom_right_message(screen, custom_font, POSTCARD_RECT.x + POSTCARD_WIDTH // 2 + 20, right_start_y, right_area_width)

# Función para mostrar el cuadro de texto
def display_text_box():
    pygame.draw.rect(screen, WHITE, TEXT_BOX_RECT, 0)
    pygame.draw.rect(screen, BLACK, TEXT_BOX_RECT, 2 if not text_box_active else 3)
    if user_input:
        default_font.render_to(screen, (TEXT_BOX_RECT.x + 10, TEXT_BOX_RECT.y + 15), user_input, BLACK)
    else:
        default_font.render_to(screen, (TEXT_BOX_RECT.x + 10, TEXT_BOX_RECT.y + 15), placeholder_text, GRAY)
    
    # Mostrar cursor parpadeante si el cuadro de texto está activo
    if text_box_active and cursor_visible:
        text_surface, _ = default_font.render(user_input, BLACK)
        text_width = text_surface.get_width()
        cursor_x = TEXT_BOX_RECT.x + 10 + text_width + 2
        cursor_y = TEXT_BOX_RECT.y + 15
        pygame.draw.line(screen, BLACK, (cursor_x, cursor_y), (cursor_x, cursor_y + text_surface.get_height()), 2)
# Función para mostrar el botón de descarga
def display_download_button(mouse_pos):
    button_color = HOVER_COLOR if DOWNLOAD_BUTTON_RECT.collidepoint(mouse_pos) else LIGHTBLUE
    pygame.draw.rect(screen, button_color, DOWNLOAD_BUTTON_RECT)
    pygame.draw.rect(screen, BLACK, DOWNLOAD_BUTTON_RECT, 2)
    default_font.render_to(screen, (DOWNLOAD_BUTTON_RECT.x + 100, DOWNLOAD_BUTTON_RECT.y + 5), "Descargar Postal", BLACK)

# Función para alternar entre frente y reverso de la postal
def flip_postal():
    global postal_front
    pygame.mixer.Sound.play(flip_sound)  # Reproducir el sonido al voltear
    postal_front = not postal_front

# Función para guardar la postal
def download_postal(information, image_path, language):
    file_path = filedialog.asksaveasfilename(defaultextension=".png", filetypes=[("PNG files", "*.png")])
    if file_path:
        # Crear una nueva imagen con el doble de la altura para almacenar ambos lados
        img = Image.new('RGB', (POSTCARD_WIDTH, POSTCARD_HEIGHT * 2), color=WHITE)
        
        # Generar la imagen del lado frontal
        front_surf = pygame.Surface((POSTCARD_WIDTH, POSTCARD_HEIGHT))
        front_surf.fill(LIGHTBLUE)
        default_font.render_to(front_surf, (POSTCARD_WIDTH // 2 - 100, POSTCARD_HEIGHT // 2 - 30), "Front Side", BLACK)
        planet = pygame.image.load(current_dir + '/resources/planetAI/' + image_path + '.jpg')
        planet = pygame.transform.scale(planet, (POSTCARD_WIDTH, POSTCARD_HEIGHT))
        planet = pygame.transform.flip(planet, True, False)
        user = pygame.image.load(current_dir + '/resources/character/cropped_face_with_transparent_bg.png')
        astronaut = pygame.image.load(current_dir + '/resources/character/astronaut.png')
        # Scale the astronaut image to make it larger
        user = pygame.transform.scale(user, (POSTCARD_WIDTH // 8, POSTCARD_WIDTH // 8))
        astronaut = pygame.transform.scale(astronaut, (POSTCARD_WIDTH * 0.75, POSTCARD_WIDTH * 0.75))

        astronaut_height = astronaut.get_height()
        astronaut_cropped = astronaut.subsurface((0, 0, astronaut.get_width(), (astronaut_height // 2) - 95))

        astronaut_x = POSTCARD_RECT.x + POSTCARD_RECT.width - (POSTCARD_WIDTH // 1.25)
        astronaut_y = POSTCARD_RECT.y + POSTCARD_RECT.height - (POSTCARD_HEIGHT * 0.25)
        front_surf.blit(planet, (0, 0))
        front_surf.blit(user, (astronaut_x + 280, astronaut_y + 53))
        front_surf.blit(astronaut_cropped, (astronaut_x, astronaut_y))

        # Render the text "Greeting from " + image_path on the upper left side
        greetings = {
            "English": "Greeting from ",
            "Spanish": "Saludos desde ",
            "French": "Salutations de ",
            "German": "Grüße aus "
        }
        custom_font3.render_to(front_surf, (20, 20), greetings[language] + image_path, WHITE)

        front_image = pygame.surfarray.array3d(front_surf)
        front_image = Image.fromarray(front_image.transpose([1, 0, 2]))  # Transponer para ajustar la orientación correcta
        img.paste(front_image, (0, 0))  # Pegar la imagen del frente en la parte superior
        # Load and transform the background image
        # Generar la imagen del lado trasero
        back_surf = pygame.Surface((POSTCARD_WIDTH, POSTCARD_HEIGHT))
        back_surf.blit(background_image, (0, 0))
        
        
        # Lado izquierdo: Usar la misma fuente y renderizado que en la vista interactiva, con ajustes de altura
        left_lines = wrap_text(information, custom_font2, POSTCARD_WIDTH // 2 - 40)
        right_lines = wrap_text(user_input, custom_font, POSTCARD_WIDTH // 2 - 40)
        
        left_start_y = POSTCARD_RECT.y + 90  # Ajusta la altura para que coincida
        for i, line in enumerate(left_lines):
            custom_font2.render_to(back_surf, (50, left_start_y + i * 40), line, BLACK)
        
        # Lado derecho: Ajustar la altura del texto
        right_start_y = POSTCARD_RECT.y + POSTCARD_HEIGHT // 2 + 20
        for i, line in enumerate(right_lines):
            custom_font.render_to(back_surf, (POSTCARD_WIDTH // 2 + 20, right_start_y + i * 40), line, BLACK)

        # Convertir el lado trasero a imagen de PIL y transponer para la orientación correcta
        back_image = pygame.surfarray.array3d(back_surf)
        back_image = Image.fromarray(back_image.transpose([1, 0, 2]))  # Transponer para corregir la orientación
        img.paste(back_image, (0, POSTCARD_HEIGHT))  # Pegar la imagen trasera debajo de la imagen frontal
        
        # Guardar la imagen final
        img.save(file_path)
        messagebox.showinfo("Postal guardada", "La postal interactiva ha sido guardada con éxito.")

# Función principal para la postal interactiva
def postcard(left_message, image_path, language):
    generate_stars()
    clock = pygame.time.Clock()
    global postal_front, text_box_active, user_input
    postal_front = True
    running = True

    while running:
        dt = clock.tick(60)
        global cursor_timer, cursor_visible
        cursor_timer += dt
        if cursor_timer >= CURSOR_BLINK_INTERVAL:
            cursor_visible = not cursor_visible
            cursor_timer = 0

        mouse_pos = pygame.mouse.get_pos()
        move_stars()
        screen.fill(BLACK)
        draw_stars()

        center_elements()
        if postal_front:
            display_front(image_path)
        else:
            display_back(left_message)

        display_text_box()
        display_download_button(mouse_pos)

        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if POSTCARD_RECT.collidepoint(mouse_pos):
                    flip_postal()
                    text_box_active = False
                elif TEXT_BOX_RECT.collidepoint(mouse_pos):
                    text_box_active = True
                elif DOWNLOAD_BUTTON_RECT.collidepoint(mouse_pos):
                    download_postal(left_message, image_path, language)
                else:
                    text_box_active = False

            elif event.type == pygame.KEYDOWN and text_box_active:
                if event.key == pygame.K_BACKSPACE:
                    backspace_held = True
                    backspace_time = 0
                    if user_input:
                        user_input = user_input[:-1]
                elif event.unicode.isprintable() and len(user_input.split()) < 10:
                    user_input += event.unicode
                else:
                    messagebox.showwarning("Límite de palabras", "El mensaje no puede tener más de 10 palabras.")

            elif event.type == pygame.KEYUP and event.key == pygame.K_BACKSPACE:
                backspace_held = False

        pygame.display.flip()

    pygame.quit() # Salir de pygame
